\subsection{Worker für Datenübermittlung}\label{subsec:Worker}
Der vorliegende Abschnitt befasst sich mit dem Teil der Wissenserwerbskomponente, der als Bindeglied zwischen den Wissenserfassungsmethoden und der Wissensbasis auftritt und in Abbildung \ref{fig:wissenserwerbskomponente} als Schnittstelle für die Datenübermittlung bezeichnet wird. Im Rahmen dieser Arbeit wird der Begriff \glqq{}\textit{Worker}\grqq{} verwendet, der für die Ausprägung dieser Schnittstelle steht. Im Folgenden wird das Konzept hinter dem Worker abstrakt skizziert und im weiteren Verlauf durch die konkrete Implementierung verdeutlicht. Der Anwendungsbereich des Workers wird in Abbildung \ref{fig:worker} dargestellt:
\begin{figure}[H] 
	\centering
	\includegraphics[width=1.0\textwidth]{images/anwendungsbereich_worker.png}
	\caption{Anwendungsbereich des Workers}
	\label{fig:worker}
\end{figure}
Grundsätzlich besteht der Worker aus zwei Komponenten, nämlich dem \glqq{}\textit{UpdateService}\grqq{} und dem \glqq{}\textit{UpdateClient}\grqq{}. Die Aufgabe des UpdateServices besteht in der Bereitstellung einer Schnittstelle, die die Daten von außen aufnimmt und die Datenübermittlung an den UpdateClient delegiert. Auf der anderen Seite stellt der UpdateClient die Methoden zur Verfügung, die für die Datenübermittlung zuständig sind.\\
Generell lässt sich der Ablauf gemäß Abbildung \ref{fig:worker} folgendermaßen beschreiben: Als Ers\-tes werden die Daten von der Wissenserfassungsmethode an den UpdateService gesendet. Darauffolgend werden sie vom UpdateService verarbeitet und für den UpdateClient vorbereitet. Im nächsten Schritt wird die Aufgabe der Datenübermittlung an den UpdateClient delegiert. Dieser erstellt die Anfrage an die Wissensbasis und teilt deren Antwort dem UpdateService mit. Anschließend verschickt der UpdateService die Rückmeldung an die Wissenserfassungsmethode.\\ 
Des Weiteren wird die Wissensträgerschnittstelle aus Abschnitt \ref{subsec:Wissensträgerschnittstelle} als Wissenserfassungsmethode betrachtet. Das Git-Repository, welches von einem Bot-Account auf Github \glqq{}geforkt\grqq{} wird\footnote{https://github.com/update-bot/paas-profiles}, stellt die Wissensbasis von \textit{PaaSfinder} dar. In anderen Worten wird das ursprüngliche Git-Repository von \textit{PaaSfinder} kopiert, sodass der Bot-Account einen schreibenden Zugriff auf die Wissensbasis erhält.\\
Technisch gesehen erfolgt der Nachrichtenaustausch zwischen Wissenserfassungsmethode, dem Worker und der Wissensbasis auf Basis des Hypertext Transfer Protocols (\acs{HTTP}) und des \ac{REST} Prinzips, das ursprünglich aus der Dissertation von Fielding \cite{fielding2000} stammt. Das zentrale Konzept von REST basiert auf Ressourcen, die im globalen Raum mithilfe eines Uniform Resource Identifiers \acs{URI}\footnote{https://tools.ietf.org/html/rfc3986} eindeutig identifiziert werden \cite[S.11,35]{tilkov2015}. Ein Vendor wird also als Ressource im JSON-Format zunächst zum Worker und anschließend zum Git-Repository geschickt.\\
Um die Daten von außen empfangen zu können, implementiert der UpdateClient eine REST Route (\glqq{}/vendor\grqq{}) definiert wird. Die Route entspricht dem HTTP-Standardroute POST\footnote{https://tools.ietf.org/html/rfc7231\#section-4.3.3} und akzeptiert die Daten im JSON-Format. Für die Implementierung der Route wird das Framework Spark\footnote{http://sparkjava.com} verwendet. Auf der Seite des UpdateClients werden die Nachrichten als Anfragen an Github mithilfe von OkHttp\footnote{https://square.github.io/okhttp}  gesendet. In Java Pseudocode lässt sich die Route folgendermaßen beschreiben (siehe Listing \ref{service}):
\begin{lstlisting}[basicstyle=\ttfamily, label=service,
					captionpos=b, caption={\glqq{}/vendor\grqq{} Route}]
post("/vendor", "application/json", (request, response) -> {
  JsonObject data = jsonParser.parse(request.body());
  
  Branch branch = new Branch(..);       
  client.postBranch(branch);
  
  File file = new File(..);
  client.putFile(file);

  PullRequest pullRequest = new PullRequest(..);
  client.postPullRequest(pullRequest);
});
\end{lstlisting}
Als Erstes werden die Daten in ein Java Objekt transformiert. Danach wird ein neuer Git-Branch erzeugt und an den UpdateClient zum Absenden weitergegeben. Sobald der Branch auf der Github-Seite erfolgreich erstellt wurde, wird die Vendor-Datei im erstellten Branch aktualisiert. Anschließend wird ein Pull-Request erzeugt und vom UpdateClient an das Git-Repository geschickt. Bedauerlicherweise lässt sich der Ablauf nicht parallelisieren, da der nächste Schritt die erfolgreiche Ausführung des vorherigen Schrittes voraussetzt. Beispielsweise setzt die Aktualisierung der Datei die Erstellung des Branches voraus, da die Datei im erstellten Branch aktualisiert wird.\\ 
Wird der oben beschriebene Ablauf auf das Beispiel mit \glqq{}Heroku\grqq{} aus Abschnitt \ref{subsec:Wissensträgerschnittstelle} übertragen, ergibt sich Folgendes: Sobald der Benutzer auf \glqq{}Submit\grqq{} klickt, werden die Daten als JSON in der POST-Anfrage an den Worker gesendet, nämlich an die Schnittstelle des UpdateService. Das erfolgreiche Branch- bzw. Pull-Request-Erstellen wird durch den HTTP-Code 201 (\glqq{}Created\grqq{}) im Response von Github mitgeteilt (siehe Listings \ref{branch} und \ref{pullrequest}). Beim erfolgreichen Updaten der Datei wird der Statuscode 200 (\glqq{}OK\grqq{}) zurückgeliefert (siehe Listing \ref{file}).
\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true, label=branch,
					captionpos=b, caption={Response bei erfolgreichem Branch-Erstellen}]
  protocol=http/1.1,
  code=201, 
  message=Created,
  url=https://api.github.com/repos/update-bot/paas-profiles/git/refs
\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true, label=file,
					captionpos=b, caption={Response bei erfolgreichem File-Update}]
  protocol=http/1.1,
  code=200, 
  message=OK, 
  url=https://api.github.com/repos/update-bot/paas-profiles/contents/profiles/heroku.json
\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true, label=pullrequest,
					captionpos=b, caption={Response bei erfolgreichem Pull-Request-Erstellen}]
  protocol=http/1.1,
  code=201,
  message=Created,
  url=https://api.github.com/repos/update-bot/paas-profiles/pulls
\end{lstlisting}
Nach erfolgreicher Erstellung des Pull-Requests kann die aktualisierte Version von Heroku auf Github überprüft werden (siehe Abbildung \ref{fig:pull-requests}). In der Detailansicht werden die Änderungen explizit gezeigt. Dabei werden die gelöschten Zeilen rot markiert und die hinzugefügten grün (siehe Abbildung \ref{fig:pull-request-detail}).
\begin{figure}[H] 
	\centering
	\includegraphics[width=1.0\textwidth]{images/pull-requests.png}
	\caption{Pull-Requests Ansicht auf Github}
	\label{fig:pull-requests}
\end{figure}
\begin{figure}[H] 
	\centering
	\includegraphics[width=1.0\textwidth]{images/pull-request-detail.png}
	\caption{Heroku Pull Request}
	\label{fig:pull-request-detail}
\end{figure}
Schließlich wird im Erfolgsfall der Statuscode 200 (\glqq{}OK\grqq{}) der Wissenserfassungsmethode mitgeteilt. Bezüglich der Fehlerbehandlung wird jeder Schritt, der sich logisch abgrenzen lässt (Branch erstellen, Datei aktualisieren und Pull-Request erstellen), in einem ei\-genen try-catch-Block innerhalb der Route in Listing \ref{service} ausgeführt, sodass der Client eine aussagekräftige Fehlermeldung erhält.