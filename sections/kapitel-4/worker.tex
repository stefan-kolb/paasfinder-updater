\subsection{Worker für Datenübermittlung}\label{subsec:Worker}
Der vorliegende Abschnitt befasst sich mit dem Teil der Wissenserwerbskomponente, der als Bindeglied zwischen den Wissenserfassungsmethoden und der Wissensbasis auftritt und in Abbildung \ref{fig:wissenserwerbskomponente} als Schnittstelle für die Datenübermittlung bezeichnet wird. Im Rahmen dieser Arbeit wird der Begriff \glqq{}\textit{Worker}\grqq{} verwendet, der für die Ausprägung dieser Schnittstelle steht. Im Folgenden wird das Konzept hinter dem Worker abstrakt skizziert und im weiteren Verlauf mit der konkreten Implementierung verdeutlicht. Der Anwendungsbereich vom Worker wird in Abbildung \ref{fig:worker} wie folgt dargestellt:
\begin{figure}[H] 
	\centering
	\includegraphics[width=1.0\textwidth]{images/anwendungsbereich_worker.png}
	\caption{Anwendungsbereich vom Worker}
	\label{fig:worker}
\end{figure}
Grundsätzlich besteht der Worker aus zwei Komponenten, nämlich \glqq{}\textit{UpdateService}\grqq{} und \glqq{}\textit{UpdateClient}\grqq{}. Die Aufgabe vom UpdateService besteht in der Bereitstellung einer Schnittstelle, die die Daten von außen aufnimmt und die Datenübermittlung an den UpdateClient delegiert. Auf der anderen Seite stellt der UpdateClient die Methoden zur Verfügung, die für die Datenübermittlung zuständig sind.\\
Generell lässt sich der Ablauf gemäß der Abbildung \ref{fig:worker} folgendermaßen beschreiben. Als erstes werden die Daten von der Wissenserfassungsmethode an den UpdateService gesendet. Darauffolgend werden die Daten vom UpdateService verarbeitet und für den UpdateClient vorbereitet. Im nächsten Schritt wird die Aufgabe der Datenübermittlung an den UpdateClient delegiert. Der UpdateClient erstellt die Anfrage an die Wissensbasis und teilt die Antwort dem UpdateService mit. Anschließend verschickt der UpdateService die Rückmeldung an die Wissenserfassungsmethode.\\ 
Im Weiteren wird die Wissensträgerschnittstelle aus dem Abschnitt \ref{subsec:Wissensträgerschnittstelle} als Wissenserfassungsmethode betrachtet. Die Wissensbasis stellt das Git-Repository von \textit{PaaSfinder} dar, das von einem Bot-Account auf Github \glqq{}geforkt\grqq{} wird\footnote{https://github.com/update-bot/paas-profiles}. In anderen Worten wird das ursprüngliche Git-Repository von \textit{PaaSfinder} kopiert, sodass der Bot-Account einen schreibenden Zugriff auf die Wissensbasis hat.\\
Technisch gesehen erfolgt der Nachrichtenaustausch zwischen Wissenserfassungsmethode, dem Worker und der Wissensbasis auf Basis von \ac{HTTP}\footnote{https://www.w3.org/Protocols} und \ac{REST} Prinzip, das ursprünglich aus der Dissertation von Fielding \cite{fielding2000} stammt. Das zentrale Konzept von REST basiert auf Ressourcen, die im globalen Raum mithilfe von \ac{URI}\footnote{https://tools.ietf.org/html/rfc3986} eindeutig identifiziert werden \cite[S.11,35]{tilkov2015}. Ein Vendor wird also als Ressource in JSON Format zunächst zum Worker und darauffolgend zum Git-Repository geschickt.\\
Um die Daten von außen empfangen zu können, implementiert der UpdateClient eine REST API, die in Form einer Route (\glqq{}/vendor\grqq{}) definiert wird. Die Route entspricht dem HTTP-Standardverb POST\footnote{https://tools.ietf.org/html/rfc7231\#section-4.3.3} und aktepriert die Daten in JSON Format. Für die Implementierung der Route wurde das Framework Spark\footnote{http://sparkjava.com} verwendet. Auf der Seite vom UpdateClient werden die Nachrichten als Anfragen an die Github API\footnote{https://developer.github.com/v3} mithilfe von OkHttp\footnote{https://square.github.io/okhttp}  gesendet. In Java Pseudocode lässt sich die Route folgendermaßen beschreiben (siehe Listing \ref{service}):
\begin{lstlisting}[basicstyle=\ttfamily, label=service,
					captionpos=b, caption={\glqq{}/vendor\grqq{} Route}]
post("/vendor", "application/json", (request, response) -> {
  JsonObject data = jsonParser.parse(request.body());
  
  Branch branch = new Branch(..);       
  client.postBranch(branch);
  
  File file = new File(..);
  client.putFile(file);

  PullRequest pullRequest = new PullRequest(..);
  client.postPullRequest(pullRequest);
});
\end{lstlisting}
Als erstes werden die Daten geparsed. Danach wird ein neuer Branch erzeugt und an den UpdateClient zum Absenden weitergegeben. Sobald der Branch auf der Github-Seite erfolgreich erstellt wurde, wird die Vendor-Datei im erstellen Branch aktualisiert. Anschließend wird ein Pull-Request erzeugt und vom UpdateClient an das Git-Repository geschickt. Bedauerlicherweise lässt sich der Ablauf nicht parallelisieren, da der nächste Schnitt die erfolgreiche Ausführung des vorherigen Schrittes voraussetzt. Beispielsweise setzt die Aktualisierung der Datei die Erstellung vom Branch voraus, da die Datei im erstellten Branch aktualisiert wird.\\ 
Wenn man den oben beschriebenen Ablauf auf das Beispiel mit \glqq{}Heroku\grqq{} aus dem Abschnitt \ref{subsec:Wissensträgerschnittstelle} überträgt, ergibt sich Folgendes. Sobald der Benutzer auf \glqq{}Submit\grqq{} klickt, werden die Daten als JSON in der POST-Anfrage an den Worker gesendet, nämlich an die Schnittstelle vom UpdateService. Das erfolgreiche Branch bzw. Pull-Request-Erstellen wird durch den Code 201 (\glqq{}Created\grqq{}) im Response der Github-API mitgeteilt (siehe Listing \ref{branch} und \ref{pullrequest}). Beim erfolgreichen Updaten der Datei wird der Statuscode 200 (\glqq{}OK\grqq{}) zurückgeliefert (siehe Listing \ref{file}).
\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true, label=branch,
					captionpos=b, caption={Response beim erfolgreichen Branch-Erstellen}]
{
  protocol=http/1.1,
  code=201, 
  message=Created,
  url=https://api.github.com/repos/update-bot/paas-profiles/git/refs
}
\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true, label=file,
					captionpos=b, caption={Response beim erfolgreichen File-Update}]
{
  protocol=http/1.1,
  code=200, 
  message=OK, 
  url=https://api.github.com/repos/update-bot/paas-profiles/contents/profiles/heroku.json
}
\end{lstlisting}

\begin{lstlisting}[basicstyle=\ttfamily, breaklines=true, label=pullrequest,
					captionpos=b, caption={Response beim erfolgreichen Pull-Request-Erstellen}]
{
  protocol=http/1.1,
  code=201,
  message=Created,
  url=https://api.github.com/repos/update-bot/paas-profiles/pulls
}
\end{lstlisting}
Nach der erfolgreichen Pull-Request-Erstellung kann der Update von Heroku auf Github betrachtet werden (siehe Abbildung \ref{fig:pull-requests}). In der Detailansicht werden ebenso die Änderungen explizit gezeigt. Dabei werden die gelöschten Zeilen als rot markiert und die hinzugefügten als grün (siehe Abbildung \ref{fig:pull-request-detail}).
\begin{figure}[H] 
	\centering
	\includegraphics[width=0.95\textwidth]{images/pull-requests.png}
	\caption{Pull-Requests Ansicht auf Github}
	\label{fig:pull-requests}
\end{figure}
\begin{figure}[H] 
	\centering
	\includegraphics[width=0.95\textwidth]{images/pull-request-detail.png}
	\caption{Heroku Pull Request}
	\label{fig:pull-request-detail}
\end{figure}
Schließlich wird im Erfolgsfall der Statuscode 200 (\glqq{}OK\grqq{}) der Wissenserfassungsmethode mitgeteilt. In Bezug auf die Fehlerbehandlung wird jeder Schritt, der sich logisch abgrenzen lässt (Branch erstellen, Datei aktualisieren und Pull-Request erstellen), in einem eigenen try-catch-Block bei der Route in \ref{service} ausgeführt, sodass der Client eine aussagekräftige Fehlermeldung bekommt.